
# 条件概率#

	所谓“条件概率”（Conditional probability），指在事件B发生的情况下，事件A发生的概率，
	用P(A|B)来表示。 计算公式为： P(A|B) = P(AB)/P(B)

	条件概率公式是一个定义公式，或者说是公理化的，不好证明和推导，只能通过逻辑来理解了：
	AB都发生的概率可以理解成B发生的概率乘以（B发生的情况下A发生的概率），
	也即P(AB)=P(B)P(A|B)，两边除以P(B)，得到： P(A|B)=P(AB)/P(B)。

# 贝叶斯定理 #

	贝叶斯定理由英国数学家贝叶斯 ( Thomas Bayes 1702-1761 )提出，
	即：P(A|B)=P(B|A)P(A)/P(B)

	有了条件概率公式，贝叶斯定理的推导和证明非常简单：
	
		P(A|B)=P(AB)/P(B),同理P(B|A)=P(BA)/P(A)
		则:P(AB)=P(A|B)P(B),P(BA)=P(B|A)P(A)
		
		P(AB)表示A、B同时发生的概率，P(BA)表示B、A同时发生的概率，根据交换律，P(AB)=P(BA)
		所以，P(A|B)P(B)=P(B|A)P(A)
		则：P(A|B)=P(B|A)P(A)/P(B)

	
- 贝叶斯定理本身和其证明过程都简单明了，看起来不起眼，但在实际应用中却显示出了令人吃惊的强大！

		在举实例之前，先了解下贝叶斯定理中的一些概念，把贝叶斯公式作下变形，得到如下形式：
		
		P(A|B) = (P(B|A)/P(B))*P(A)
		
		一种理解是：
			详细参考：http://blog.csdn.net/saltriver/article/details/52876579

			把P(A)称为“先验概率”（Prior probability），即在B事件发生之前，我们对A事件概率的一个判断。
			P(A|B)称为“后验概率”（Posterior probability），即在B事件发生之后，我们对A事件概率的重新评估。
			P(B|A)/P(B)称为“调整因子”，调整因子可以大于1，也可以小于1，即B事件发生后，
			           对A事件发生的概率是增强作用还是削弱作用。
		
			即贝叶斯定理可表述成： 后验概率 = 调整因子 * 先验概率

		另一种理解是：
			https://baike.baidu.com/item/%E8%B4%9D%E5%8F%B6%E6%96%AF%E5%85%AC%E5%BC%8F/9683982
			
			P(A)是A的先验概率或边缘概率。 之所以称为"先验"是因为它不考虑任何B方面的因素。
			P(A|B)是已知B发生后A的条件概率，也由于得自B的取值而被称作A的后验概率。
			P(B|A)是已知A发生后B的条件概率，也由于得自A的取值而被称作B的后验概率。
			P(B)是B的先验概率或边缘概率，也作标准化常量（normalized constant）。

			按这些术语，Bayes法则可表述为：
				后验概率 = (似然度 * 先验概率)/标准化常量. 也就是说，后验概率与先验概率和似然度的乘积成正比。

			另外，比例P(B|A)/P(B)也有时被称作标准似然度（standardised likelihood），Bayes法则可表述为： 
				后验概率 = 标准似然度 * 先验概率

- 贝叶斯定理在做判断上的应用

		有两个碗，1号碗里有30颗水果糖和10块巧克力糖，2号碗里有20颗水果糖和20块巧克力糖。然后把碗盖住。
		随机选择一个碗，从里面摸出了一颗水果糖。问题：这颗水果糖来自1号碗的概率是多少？
	
			P(1号碗|水果糖)=(P(水果糖|1号碗)/P(水果糖))*P(1号碗)
	
# 似然函数 #

	在数理统计学中，似然函数是一种关于统计模型中的参数的函数，表示参数的似然性。
	
	概率 用于在已知一些参数的情况下，预测接下来的观测所得到的结果，
	而似然性 则是用于在已知某些观测所得到的结果时，对有关事物性质的参数进行估计。
	在这种意义上，似然函数可以理解为条件概率的逆反。

	在已知某个参数B时，事件A会发生的概率写作：
		P(A|B)=P(AB)/P(B)
	利用贝叶斯定理，有：
		P(B|A)=P(A|B)*P(B)/P(A)
	
	因此，可以反过来构造表示似然性的方法：
	已知有事件A发生，运用似然函数 L(B|A)，我们估计参数B的可能性。



# 梯度 #


# 卷积 #

	卷积的重要的物理意义是：一个函数（如：单位响应）在另一个函数（如：输入信号）上的加权叠加。

	卷积表示为y(n)=x(n)∗h(n)
	使用离散数列来理解卷积会更形象一点，我们把y(n)的序列表示成y(0),y(1),y(2),⋯, 这是系统响应出来的信号。
	同理，x(n)的对应时刻的序列为x(0),x(1),x(2),⋯
	其实我们如果没有学过信号与系统，就常识来讲，系统的响应不仅与当前时刻系统的输入有关，也跟之前若干时刻的输入有关，
	因为我们可以理解为这是之前时刻的输入信号经过一种过程（这种过程可以是递减，削弱，或其他）对现在时刻系统输出的影响，
	那么显然，我们计算系统输出时就必须考虑现在时刻的信号输入的响应以及之前若干时刻信号输入的响应之“残留”影响的一个叠加效果。

	参考：http://blog.csdn.net/bitcarmanlee/article/details/54729807